"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pity = exports.PUBLIC_DATA_KEY = void 0;
const core_util_is_1 = require("core-util-is");
const http_status_codes_1 = __importDefault(require("http-status-codes"));
const verror_1 = require("verror");
/**
 * The key used to store client information in VError's `info`. A symbol would
 * be ideal but `VError` doesn't currently support it.
 */
exports.PUBLIC_DATA_KEY = '__Pity_clientData';
/** Error class with optional client-side metadata. */
class Pity extends verror_1.VError {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    constructor(arg, opts) {
        var _a, _b, _c;
        const cfg = normalizeConfig(arg);
        const info = (_a = cfg.info) !== null && _a !== void 0 ? _a : {};
        if (cfg.publicCode !== undefined) {
            info[exports.PUBLIC_DATA_KEY] = {
                code: cfg.publicCode,
                message: cfg.message,
                details: cfg.info ? { ...cfg.info } : undefined,
            };
        }
        else if (Array.isArray(cfg.cause)) {
            for (const err of cfg.cause) {
                const data = Pity.publicData(err);
                if (data) {
                    info[exports.PUBLIC_DATA_KEY] = data;
                    break;
                }
            }
        }
        super({
            name: (_b = opts === null || opts === void 0 ? void 0 : opts.name) !== null && _b !== void 0 ? _b : new.target.name,
            info,
            cause: Array.isArray(cfg.cause)
                ? verror_1.VError.errorFromList(cfg.cause)
                : cfg.cause,
            constructorOpt: (_c = opts === null || opts === void 0 ? void 0 : opts.copt) !== null && _c !== void 0 ? _c : new.target,
        }, cfg.message);
    }
    /**
     * Returns the error's HTTP status code if present in the error itself or one
     * of its causes.
     */
    static publicCode(err) {
        var _a;
        // `VError.info` throws if given a non-native error.
        return core_util_is_1.isError(err) ? (_a = verror_1.VError.info(err)[exports.PUBLIC_DATA_KEY]) === null || _a === void 0 ? void 0 : _a.code : undefined;
    }
    /**
     * Extracts the data to send back to the client from an error. If the error is
     * not a public `Pity` error and does not have any such causes, a generic
     * internal server error message will be returned.
     */
    static publicData(err) {
        const data = core_util_is_1.isError(err) ? verror_1.VError.info(err)[exports.PUBLIC_DATA_KEY] : undefined;
        return (data !== null && data !== void 0 ? data : {
            code: http_status_codes_1.default.INTERNAL_SERVER_ERROR,
            message: http_status_codes_1.default.getStatusText(http_status_codes_1.default.INTERNAL_SERVER_ERROR),
        });
    }
    /** Convenience client error factory generator. */
    static publicFactory(code) {
        function newError(cfg) {
            return new Pity({ ...normalizeConfig(cfg !== null && cfg !== void 0 ? cfg : code), publicCode: code }, { copt: newError });
        }
        return newError;
    }
}
exports.Pity = Pity;
// 400s
Pity.badSyntax = Pity.publicFactory(400);
Pity.unauthorized = Pity.publicFactory(401);
Pity.paymentRequired = Pity.publicFactory(402);
Pity.forbidden = Pity.publicFactory(403);
Pity.notFound = Pity.publicFactory(404);
Pity.methodNotAllowed = Pity.publicFactory(405);
Pity.notAcceptable = Pity.publicFactory(406);
Pity.proxyAuthenticationRequired = Pity.publicFactory(407);
Pity.requestTimeout = Pity.publicFactory(408);
Pity.conflict = Pity.publicFactory(409);
Pity.gone = Pity.publicFactory(410);
Pity.lengthRequired = Pity.publicFactory(411);
Pity.preconditionFailed = Pity.publicFactory(412);
Pity.requestTooLong = Pity.publicFactory(413);
Pity.requestUriTooLong = Pity.publicFactory(414);
Pity.unsupportedMediaType = Pity.publicFactory(415);
Pity.requestedRangeNotSatisfiable = Pity.publicFactory(416);
Pity.expectationFailed = Pity.publicFactory(417);
Pity.imATeapot = Pity.publicFactory(418);
Pity.insufficientSpaceOnResource = Pity.publicFactory(419);
Pity.methodFailure = Pity.publicFactory(420);
Pity.unprocessableEntity = Pity.publicFactory(422);
Pity.locked = Pity.publicFactory(423);
Pity.failedDependency = Pity.publicFactory(424);
Pity.preconditionRequired = Pity.publicFactory(428);
Pity.tooManyRequests = Pity.publicFactory(429);
Pity.requestHeaderFieldsTooLarge = Pity.publicFactory(431);
Pity.unavailableForLegalReasons = Pity.publicFactory(451);
// 500s
Pity.internalServerError = Pity.publicFactory(500);
Pity.notImplemented = Pity.publicFactory(501);
Pity.badGateway = Pity.publicFactory(502);
Pity.serviceUnavailable = Pity.publicFactory(503);
Pity.gatewayTimeout = Pity.publicFactory(504);
Pity.httpVersionNotSupported = Pity.publicFactory(505);
Pity.insufficientStorage = Pity.publicFactory(507);
Pity.networkAuthenticationRequired = Pity.publicFactory(511);
function normalizeConfig(cfg) {
    if (typeof cfg == 'number') {
        return { publicCode: cfg, message: http_status_codes_1.default.getStatusText(cfg) };
    }
    if (typeof cfg == 'string') {
        return { message: cfg };
    }
    return cfg;
}
